write.csv(dfReleases, "LakePowellReleases.csv")
# Convert API Date Time to POSIXct
dfReleases$DateTimePos <- as.POSIXct(as.character(dfReleases$DATETIME), format = "%m/%d/%Y %H:%M")
# Replace NaNs with NA in all columns
dfReleases <- na.omit(dfReleases)
#Convert to xts
dfXtsRelease <- xts(cbind(dfReleases$PowerRelease, dfReleases$BypassRelease, dfReleases$SpillwayRelease, dfReleases$TotalRelease), order.by=dfReleases$DateTimePos)
# #Plot the Release dygraph
# dygraph(dfXtsRelease, ylab = "Release (cfs)") %>% dyRangeSelector() %>%
#   dySeries("V1", label = "PowerRelease") %>%
#   dySeries("V2", label = "BypassRelease") %>%
#   dySeries("V3", label = "SpillwayRelease") %>%
#   dySeries("V4", label = "TotalRelease") # %>%
# #  dySeries("V5", label = "Outside") %>%
#dyLimit(32, color = "red")
###### Read in Temperature data from Grand Canyon Monitoring and Research Center
####
dfTemperature <- read.csv(file = "Data/gcmrc20250709125927.tsv", sep = "\t")
colnames(dfTemperature) <- c("DateTime", "TemperatureC")
# Filter for top of the hour (00:00)
dfTemperature$Minute <- minute(dfTemperature$DateTime)
dfTemperature <- dfTemperature %>% filter(Minute == 0)
dfTemperature$TemperatureCRound <- round(dfTemperature$TemperatureC, 1)
dfTemperature$TemperatureC <- na_if(dfTemperature$TemperatureC, -999)
#Convert DateTime to POSIXct
dfTemperature$DateTimePos <- as.POSIXct(as.character(dfTemperature$DateTime), format = "%Y-%m-%d %H:%M:%S")
dfTemperature <- na.omit(dfTemperature)
#Convert to xts
dfXtsTemperature <- xts(cbind(dfTemperature$TemperatureC), order.by=dfTemperature$DateTimePos)
# dygraph(dfXtsTemperature, ylab = "Temperature (oC)") %>% dyRangeSelector() %>%
#   dySeries("V1", label = "Temperature") #%>%
###### Do a combined Release-Temperature plot
#Left Join the Temperature data to the release data so only have hourly data.
dfReleasesTemperature <- left_join(dfReleases, dfTemperature, by = c("DateTimePos" = "DateTimePos"))
dfReleasesTemperature <- na.omit(dfReleasesTemperature)
#Convert to xts
dfXtsReleasesTemperature <- xts(cbind(dfReleasesTemperature$PowerRelease, dfReleasesTemperature$BypassRelease, dfReleasesTemperature$SpillwayRelease, dfReleasesTemperature$TotalRelease, dfReleasesTemperature$TemperatureC), order.by = dfReleasesTemperature$DateTimePos)
#Plot the Release - Temperature dygraph
dygraph(dfXtsReleasesTemperature) %>% dyRangeSelector() %>%
dyAxis("y", label = "Release (cfs)") %>%
#dyAxis("y2", label = "Temperature (oC)", independentTicks = TRUE, axisLabelFormatter = htmlwidgets::JS("function(value) {return value.toFixed(1);")) %>% ## Round to 1 decimal places for y2-axis) %>%
dyAxis("y2", label = "Temperature (oC)", independentTicks = TRUE) %>%
dySeries("V1", label = "PowerRelease") %>%
dySeries("V2", label = "BypassRelease") %>%
dySeries("V3", label = "SpillwayRelease") %>%
dySeries("V4", label = "TotalRelease")  %>%
dySeries("V5", label = "Temperature", axis = "y2", strokeWidth = 3)
#### Build a histogram of daily change in temperature when bypass releases are happening.
dfReleasesTemperature$Day <- day(dfReleasesTemperature$DateTime)
dfReleasesTemperature$Month <- month(dfReleasesTemperature$DateTime)
dfReleasesTemperature$Year <- year(dfReleasesTemperature$DateTime)
dfReleasesTemperature$MonthName <- month.name[dfReleasesTemperature$Month]
#Calculate average temperature when bypass release is active
dfDailyBypassTemperature <- dfReleasesTemperature %>% filter(dfReleasesTemperature$BypassRelease > 2000) %>%
group_by(Year, Month, MonthName, Day) %>% summarise (AverageBypassTemp = mean(TemperatureC))
#Calculate average temperature when bypass release is not active (turbine only release)
dfDailyTurbineTemperature <- dfReleasesTemperature %>% filter(dfReleasesTemperature$BypassRelease == 0) %>%
group_by(Year, Month, MonthName, Day) %>% summarise (AverageTurbineTemp = mean(TemperatureC))
#Right join so we get daily Bypass Temperature and Turbine temperature on the same day
dfDailyTemp <- left_join(dfDailyBypassTemperature, dfDailyTurbineTemperature, by = c("Day"="Day", "Month" = "Month", "Year" = "Year"))
dfDailyTemp$Difference <- dfDailyTemp$AverageTurbineTemp - dfDailyTemp$AverageBypassTemp
#Load the color palettes
palBlues <- brewer.pal(9, "Blues")
palReds <- brewer.pal(9, "Reds")
palGreys <- brewer.pal(9, "Greys")
# Histogram of daily temperature changes
ggplot(dfDailyTemp, aes(x = Difference)) +
geom_histogram(binwidth = 0.5, fill = palGreys[3], color = "black") +
#scale_color_manual(values = cColorsToPlot) +
#scale_linetype_manual(values = c("solid","longdash")) +
scale_x_continuous(breaks = seq(-0.5,3,0.5)) +
#Make one combined legend
#guides(color = guide_legend(""), linetype = guide_legend("")) +
theme_bw() +
labs(x="Difference between Day and Night temperatures (oC)", y="Number of Days") +
#theme(text = element_text(size=20), legend.title=element_blank(), legend.text=element_text(size=18),
#      legend.position = c(0.8,0.7))
theme(text = element_text(size=20)) #, legend.title = element_text("Annual Release\nMAF"), legend.text=element_text(size=14), axis.text.x = element_text(size=12))
dygraph(dfXtsReleasesTemperature) %>% dyRangeSelector() %>%
dyAxis("y", label = "Release (cfs)") %>%
#dyAxis("y2", label = "Temperature (oC)", independentTicks = TRUE, axisLabelFormatter = htmlwidgets::JS("function(value) {return value.toFixed(1);")) %>% ## Round to 1 decimal places for y2-axis) %>%
dyAxis("y2", label = "Temperature (oC)", independentTicks = TRUE) %>%
dySeries("V1", label = "PowerRelease") %>%
dySeries("V2", label = "BypassRelease") %>%
dySeries("V3", label = "SpillwayRelease") %>%
dySeries("V4", label = "TotalRelease")  %>%
dySeries("V5", label = "Temperature", axis = "y2", strokeWidth = 3)
#Plot the Release dygraph
dygraph(dfXtsRelease, ylab = "Release (cfs)") %>% dyRangeSelector() %>%
dySeries("V1", label = "PowerRelease") %>%
dySeries("V2", label = "BypassRelease") %>%
dySeries("V3", label = "SpillwayRelease") %>%
dySeries("V4", label = "TotalRelease") # %>%
dfTemperature <- read.csv(file = "Data/gcmrcTemp.tsv", sep = "\t")
colnames(dfTemperature) <- c("DateTime", "TemperatureC")
# Filter for top of the hour (00:00)
dfTemperature$Minute <- minute(dfTemperature$DateTime)
dfTemperature <- dfTemperature %>% filter(Minute == 0)
dfTemperature$TemperatureCRound <- round(dfTemperature$TemperatureC, 1)
dfTemperature$TemperatureC <- na_if(dfTemperature$TemperatureC, -999)
#Convert DateTime to POSIXct
dfTemperature$DateTimePos <- as.POSIXct(as.character(dfTemperature$DateTime), format = "%Y-%m-%d %H:%M:%S")
dfTemperature <- na.omit(dfTemperature)
#Convert to xts
dfXtsTemperature <- xts(cbind(dfTemperature$TemperatureC), order.by=dfTemperature$DateTimePos)
# dygraph(dfXtsTemperature, ylab = "Temperature (oC)") %>% dyRangeSelector() %>%
#   dySeries("V1", label = "Temperature") #%>%
###### Do a combined Release-Temperature plot
#Left Join the Temperature data to the release data so only have hourly data.
dfReleasesTemperature <- left_join(dfReleases, dfTemperature, by = c("DateTimePos" = "DateTimePos"))
dfReleasesTemperature <- na.omit(dfReleasesTemperature)
#Convert to xts
dfXtsReleasesTemperature <- xts(cbind(dfReleasesTemperature$PowerRelease, dfReleasesTemperature$BypassRelease, dfReleasesTemperature$SpillwayRelease, dfReleasesTemperature$TotalRelease, dfReleasesTemperature$TemperatureC), order.by = dfReleasesTemperature$DateTimePos)
#Plot the Release - Temperature dygraph
dygraph(dfXtsReleasesTemperature) %>% dyRangeSelector() %>%
dyAxis("y", label = "Release (cfs)") %>%
#dyAxis("y2", label = "Temperature (oC)", independentTicks = TRUE, axisLabelFormatter = htmlwidgets::JS("function(value) {return value.toFixed(1);")) %>% ## Round to 1 decimal places for y2-axis) %>%
dyAxis("y2", label = "Temperature (oC)", independentTicks = TRUE) %>%
dySeries("V1", label = "PowerRelease") %>%
dySeries("V2", label = "BypassRelease") %>%
dySeries("V3", label = "SpillwayRelease") %>%
dySeries("V4", label = "TotalRelease")  %>%
dySeries("V5", label = "Temperature", axis = "y2", strokeWidth = 3)
View(dfReleases)
write.csv(dfReleases, "LakePowellReleases.csv")
View(dfDailyBypassTemperature)
View(dfDailyTurbineTemperature)
dfDailyTemp <- left_join(dfDailyBypassTemperature, dfDailyTurbineTemperature, by = c("Day"="Day", "Month" = "Month", "Year" = "Year"))
colnames(dfDailyBypassTemperature)
colnames(dfDailyTurbineTemperature)
dfReleasesTemperature$Day <- day(dfReleasesTemperature$DateTime)
dfReleasesTemperature$Month <- month(dfReleasesTemperature$DateTime)
dfReleasesTemperature$Year <- year(dfReleasesTemperature$DateTime)
dfReleasesTemperature$MonthName <- month.name[dfReleasesTemperature$Month]
#Calculate average temperature when bypass release is active
dfDailyBypassTemperature <- dfReleasesTemperature %>% filter(dfReleasesTemperature$BypassRelease > 2000) %>%
group_by(Year, Month, MonthName, Day) %>% summarise (AverageBypassTemp = mean(TemperatureC))
#Calculate average temperature when bypass release is not active (turbine only release)
dfDailyTurbineTemperature <- dfReleasesTemperature %>% filter(dfReleasesTemperature$BypassRelease == 0) %>%
group_by(Year, Month, MonthName, Day) %>% summarise (AverageTurbineTemp = mean(TemperatureC))
#Right join so we get daily Bypass Temperature and Turbine temperature on the same day
dfDailyTemp <- left_join(dfDailyBypassTemperature, dfDailyTurbineTemperature, by = c("Day"="Day", "Month" = "Month", "Year" = "Year"))
dfDailyTemp$Difference <- dfDailyTemp$AverageTurbineTemp - dfDailyTemp$AverageBypassTemp
# Remove everything
rm(list=ls())
cPackages <- c("versions", "googlesheets4", "dygraphs", "tidyquant", "xts", "tidyverse", "tidyquant","lubridate", "stringr", "rvest", "RColorBrewer" )
# Install packages not yet installed
installed_packages <- cPackages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(cPackages[!installed_packages])
}
# Packages loading
invisible(lapply(cPackages, library, character.only = TRUE))
#Load the required library
#Load correct versions of libraries
install.versions('cli', '3.4.0')
#######
###Read Reclamation API Release data data into R
# Get Today's date as ending time
vDateToday = Sys.Date()
sStartDate = '2024-05-01' # May 1, 2025
sFormat = 'table'
# As CSV
sAPI_Request <- paste0('https://www.usbr.gov/pn-bin/hdb/hdb.pl?svr=uchdb2&sdi=1862%2C1872%2C4167%2C4166&tstp=HR&t1=',sStartDate,'T00:00&t2=',vDateToday,'T00:00&table=R&mrid=0&format=',sFormat)
sWebpage <- read_html(sAPI_Request)
tables <- sWebpage %>% html_table()
dfReleases <- as.data.frame(tables[1])
#Turn to meaningful column names
cColNames <- colnames(dfReleases)
cColNames[2:5] <- c("PowerRelease", "TotalRelease", "BypassRelease", "SpillwayRelease")
colnames(dfReleases) <- cColNames
#Save to csv
write.csv(dfReleases, "LakePowellReleases.csv")
# Convert API Date Time to POSIXct
dfReleases$DateTimePos <- as.POSIXct(as.character(dfReleases$DATETIME), format = "%m/%d/%Y %H:%M")
# Replace NaNs with NA in all columns
dfReleases <- na.omit(dfReleases)
#Convert to xts
dfXtsRelease <- xts(cbind(dfReleases$PowerRelease, dfReleases$BypassRelease, dfReleases$SpillwayRelease, dfReleases$TotalRelease), order.by=dfReleases$DateTimePos)
#Plot the Release dygraph
dygraph(dfXtsRelease, ylab = "Release (cfs)") %>% dyRangeSelector() %>%
dySeries("V1", label = "PowerRelease") %>%
dySeries("V2", label = "BypassRelease") %>%
dySeries("V3", label = "SpillwayRelease") %>%
dySeries("V4", label = "TotalRelease") # %>%
# #  dySeries("V5", label = "Outside") %>%
#dyLimit(32, color = "red")
###### Read in Temperature data from Grand Canyon Monitoring and Research Center
####
dfTemperature <- read.csv(file = "Data/gcmrcTemp.tsv", sep = "\t")
colnames(dfTemperature) <- c("DateTime", "TemperatureC")
# Filter for top of the hour (00:00)
dfTemperature$Minute <- minute(dfTemperature$DateTime)
dfTemperature <- dfTemperature %>% filter(Minute == 0)
dfTemperature$TemperatureCRound <- round(dfTemperature$TemperatureC, 1)
dfTemperature$TemperatureC <- na_if(dfTemperature$TemperatureC, -999)
#Convert DateTime to POSIXct
dfTemperature$DateTimePos <- as.POSIXct(as.character(dfTemperature$DateTime), format = "%Y-%m-%d %H:%M:%S")
dfTemperature <- na.omit(dfTemperature)
#Convert to xts
dfXtsTemperature <- xts(cbind(dfTemperature$TemperatureC), order.by=dfTemperature$DateTimePos)
# dygraph(dfXtsTemperature, ylab = "Temperature (oC)") %>% dyRangeSelector() %>%
#   dySeries("V1", label = "Temperature") #%>%
###### Do a combined Release-Temperature plot
#Left Join the Temperature data to the release data so only have hourly data.
dfReleasesTemperature <- left_join(dfReleases, dfTemperature, by = c("DateTimePos" = "DateTimePos"))
dfReleasesTemperature <- na.omit(dfReleasesTemperature)
#Convert to xts
dfXtsReleasesTemperature <- xts(cbind(dfReleasesTemperature$PowerRelease, dfReleasesTemperature$BypassRelease, dfReleasesTemperature$SpillwayRelease, dfReleasesTemperature$TotalRelease, dfReleasesTemperature$TemperatureC), order.by = dfReleasesTemperature$DateTimePos)
#Plot the Release - Temperature dygraph
dygraph(dfXtsReleasesTemperature) %>% dyRangeSelector() %>%
dyAxis("y", label = "Release (cfs)") %>%
#dyAxis("y2", label = "Temperature (oC)", independentTicks = TRUE, axisLabelFormatter = htmlwidgets::JS("function(value) {return value.toFixed(1);")) %>% ## Round to 1 decimal places for y2-axis) %>%
dyAxis("y2", label = "Temperature (oC)", independentTicks = TRUE) %>%
dySeries("V1", label = "PowerRelease") %>%
dySeries("V2", label = "BypassRelease") %>%
dySeries("V3", label = "SpillwayRelease") %>%
dySeries("V4", label = "TotalRelease")  %>%
dySeries("V5", label = "Temperature", axis = "y2", strokeWidth = 3)
#### Build a histogram of daily change in temperature when bypass releases are happening.
dfReleasesTemperature$Day <- day(dfReleasesTemperature$DateTime)
dfReleasesTemperature$Month <- month(dfReleasesTemperature$DateTime)
dfReleasesTemperature$Year <- year(dfReleasesTemperature$DateTime)
dfReleasesTemperature$MonthName <- month.name[dfReleasesTemperature$Month]
#Calculate average temperature when bypass release is active
dfDailyBypassTemperature <- dfReleasesTemperature %>% filter(dfReleasesTemperature$BypassRelease > 2000) %>%
group_by(Year, Month, MonthName, Day) %>% summarise (AverageBypassTemp = mean(TemperatureC))
#Calculate average temperature when bypass release is not active (turbine only release)
dfDailyTurbineTemperature <- dfReleasesTemperature %>% filter(dfReleasesTemperature$BypassRelease == 0) %>%
group_by(Year, Month, MonthName, Day) %>% summarise (AverageTurbineTemp = mean(TemperatureC))
#Right join so we get daily Bypass Temperature and Turbine temperature on the same day
dfDailyTemp <- left_join(dfDailyBypassTemperature, dfDailyTurbineTemperature, by = c("Day"="Day", "Month" = "Month", "Year" = "Year"))
dfDailyTemp$Difference <- dfDailyTemp$AverageTurbineTemp - dfDailyTemp$AverageBypassTemp
#Load the color palettes
palBlues <- brewer.pal(9, "Blues")
palReds <- brewer.pal(9, "Reds")
palGreys <- brewer.pal(9, "Greys")
# Histogram of daily temperature changes
ggplot(dfDailyTemp, aes(x = Difference)) +
geom_histogram(binwidth = 0.5, fill = palGreys[3], color = "black") +
#scale_color_manual(values = cColorsToPlot) +
#scale_linetype_manual(values = c("solid","longdash")) +
scale_x_continuous(breaks = seq(-0.5,3,0.5)) +
#Make one combined legend
#guides(color = guide_legend(""), linetype = guide_legend("")) +
theme_bw() +
labs(x="Difference between Day and Night temperatures (oC)", y="Number of Days") +
#theme(text = element_text(size=20), legend.title=element_blank(), legend.text=element_text(size=18),
#      legend.position = c(0.8,0.7))
theme(text = element_text(size=20)) #, legend.title = element_text("Annual Release\nMAF"), legend.text=element_text(size=14), axis.text.x = element_text(size=12))
# Histogram of daily temperature changes by Month
ggplot(dfDailyTemp, aes(x = Difference)) +
geom_histogram(binwidth = 0.5, fill = palGreys[3], color = "black") +
#scale_color_manual(values = cColorsToPlot) +
#scale_linetype_manual(values = c("solid","longdash")) +
scale_x_continuous(breaks = seq(-0.5,3,0.5)) +
#Make one combined legend
#guides(color = guide_legend(""), linetype = guide_legend("")) +
facet_wrap( ~ factor(dfDailyTemp$MonthName.x, levels = month.name ), ncol = 1) +
theme_bw() +
labs(x="Difference between Day and Night temperatures (oC)", y="Number of Days") +
#theme(text = element_text(size=20), legend.title=element_blank(), legend.text=element_text(size=18),
#      legend.position = c(0.8,0.7))
theme(text = element_text(size=20)) #, legend.title = element_text("Annual Release\nMAF"), legend.text=element_text(size=14), axis.text.x = element_text(size=12))
dfProfileJoined <- left_join(dfProfileData, dfSiteVisitData, by = c("TripID" = "TripID", "StationID" = "StationID"))
rm(list=ls())
cPackages <- c("versions", "googlesheets4", "dygraphs", "tidyquant", "xts", "tidyverse", "tidyquant","lubridate", "stringr", "rvest", "RColorBrewer", "readxl" )
# Install packages not yet installed
installed_packages <- cPackages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(cPackages[!installed_packages])
}
# Packages loading
invisible(lapply(cPackages, library, character.only = TRUE))
#Load the required library
#Load correct versions of libraries
install.versions('cli', '3.4.0')
#######
###Read all data data into R
sStationDataFile <- 'data/StationData_LakePowell_1964-2022.csv'
sSiteVisitDataFile <- 'data/SiteVisitData_LakePowell_1964-2022.csv'
sProfileDataFile <- 'data/ProfileData_LakePOwell_1965-2022.csv'
dfStationData <- read.csv(sStationDataFile)
dfSiteVisitData <- read.csv(sSiteVisitDataFile)
dfProfileData <- read.csv(sProfileDataFile)
# Read elevation-storage data in from Excel
sExcelFile <- 'data/Lake_Powell_Area_Capacity_Table_report_Final.xlsx'
dfPowellBathymetry <- read_excel(sExcelFile, sheet = "2017Bathymetry",  range = "A1:D582")
dfProfileJoined <- left_join(dfProfileData, dfSiteVisitData, by = c("TripID" = "TripID", "StationID" = "StationID"))
View(dfProfileJoined)
dfProfileJoined <- left_join(dfProfileData, dfSiteVisitData, by = c("TripID" = "TripID", "StationID" = "StationID", "CollectionDateTime" = "CollectionDataTime"))
View(dfProfileData)
View(dfSiteVisitData)
dfProfileJoined <- left_join(dfProfileData, dfSiteVisitData, by = c("TripID" = "TripID", "StationID" = "StationID", "CollectionDateTime" = "CollectionDateTime"))
dfProfileJoined <- left_join(dfProfileJoined, dfStationData, by = c("StationID" = "StationID"))
View(dfSiteVisitData)
dfProfileJoined <- left_join(dfProfileData, dfSiteVisitData, by = c("TripID" = "TripID", "StationID" = "StationID", "CollectionDateTime" = "CollectionDateTime"))
dfProfileJoined <- left_join(dfProfileData, dfSiteVisitData, by = c("TripID" = "TripID", "StationID" = "StationID"))
dfProfileJoined <- left_join(dfProfileJoined, dfStationData, by = c("StationID" = "StationID"))
# New function interp2 to return NAs for values outside interpolation range (from https://stackoverflow.com/questions/47295879/using-interp1-in-r)
interp2 <- function(x, y, xi = x, ...) {
yi <- rep(NA, length(xi));
sel <- which(xi >= range(x)[1] & xi <= range(x)[2]);
yi[sel] <- interp1(x = x, y = y, xi = xi[sel], ...);
return(yi);
}
dfProfileJoined$Depth_ft <- 3.28 * dfProfileJoined$Depth_m
dfProfileJoined$LakeElevation_ft <- 3.28 * dfProfileJoined$LakeElevation_m
dfProfileJoined$BottomSounding_ft <- 3.28 * dfProfileJoined$BottomSounding_m
dfProfileJoined$IntakeDepth_ft <- 3.28 * dfProfileJoined$IntakeDepth_m
## Lake Powell Temperature Profiles
##
#
# This script does 3 things:
#
#   1. Ingests temperature profile data from the USGS Lake Powell profiles:
#         Andrews, C.M., and Deemer, B.R., 2022, Limnology data from Lake Powell, desert southwest USA (ver. 2.1, September 2024): U.S. Geological Survey data release, https://doi.org/10.5066/P9ZIKVYW.
#       https://www.sciencebase.gov/catalog/item/62b39805d34e8f4977cb788c
#
#       Files: StationData_LakePowell_1964-2022.csv (Station Meta data)
#              SiteVisitData_LakePowell_1964-2022.csv (Site visit meta data, including Lake Elevation and Intake Depth)
#              ProfileData_LakePOwell_1965-2022.csv (Temperature-Depth data)
#
#   2. Ingest Lake Powell Bathymetry (2017) from Bradley, D., and Collins, K. (2022). "Lake Powell 2017 Area and Capacity Tables." ENV-2021-98, Reclamation. https://doi.org/10.5066/P9O3IPG3.
#        File: Lake_Powell_Area_Capacity_Table_report_Final.xlsx
#       Note: this excel file was created from the raw data published in pdf form. See here for more specifics:
#         https://github.com/dzeke/ColoradoRiverCollaborate/tree/main/LakePowellNewBathymetry
#
#   3. Joins all the above files together to get a single data frame from which we will perform the analysis.
#
#   https://www.usbr.gov/pn-bin/hdb/hdb.pl?svr=uchdb2&sdi=1862%2C1872%2C4167%2C4166&tstp=HR&t1=2024-05-01T00:00&t2=2025-07-10T00:00&table=R&mrid=0&format=csv
#
# David Rosenberg
# August 22, 2025
#Versions to use
#R version 4.1.1. Download from https://cran.r-project.org/.
#R Studio 2021.09.0. Build 351 - Download from https://www.rstudio.com/.
# Remove everything
rm(list=ls())
cPackages <- c("versions", "googlesheets4", "dygraphs", "tidyquant", "xts", "tidyverse", "tidyquant","lubridate", "stringr", "rvest", "RColorBrewer", "readxl" )
# Install packages not yet installed
installed_packages <- cPackages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(cPackages[!installed_packages])
}
# Packages loading
invisible(lapply(cPackages, library, character.only = TRUE))
#Load the required library
#Load correct versions of libraries
install.versions('cli', '3.4.0')
# New function interp2 to return NAs for values outside interpolation range (from https://stackoverflow.com/questions/47295879/using-interp1-in-r)
interp2 <- function(x, y, xi = x, ...) {
yi <- rep(NA, length(xi));
sel <- which(xi >= range(x)[1] & xi <= range(x)[2]);
yi[sel] <- interp1(x = x, y = y, xi = xi[sel], ...);
return(yi);
}
#######
###Read all data data into R
sStationDataFile <- 'data/StationData_LakePowell_1964-2022.csv'
sSiteVisitDataFile <- 'data/SiteVisitData_LakePowell_1964-2022.csv'
sProfileDataFile <- 'data/ProfileData_LakePOwell_1965-2022.csv'
dfStationData <- read.csv(sStationDataFile)
dfSiteVisitData <- read.csv(sSiteVisitDataFile)
dfProfileData <- read.csv(sProfileDataFile)
# Read elevation-storage data in from Excel
sExcelFile <- 'data/Lake_Powell_Area_Capacity_Table_report_Final.xlsx'
dfPowellBathymetry <- read_excel(sExcelFile, sheet = "2017Bathymetry",  range = "A1:D582")
####### Join the data
# Join Profile data to site visit data
# Seems like this statement should work (joining on the datetime), but we lose the intake and elevation data
#dfProfileJoined <- left_join(dfProfileData, dfSiteVisitData, by = c("TripID" = "TripID", "StationID" = "StationID", "CollectionDateTime" = "CollectionDateTime"))
dfProfileJoined <- left_join(dfProfileData, dfSiteVisitData, by = c("TripID" = "TripID", "StationID" = "StationID"))
# Join Profile and StationData
dfProfileJoined <- left_join(dfProfileJoined, dfStationData, by = c("StationID" = "StationID"))
# Convert meters to feet
dfProfileJoined$Depth_ft <- 3.28 * dfProfileJoined$Depth_m
dfProfileJoined$LakeElevation_ft <- 3.28 * dfProfileJoined$LakeElevation_m
dfProfileJoined$BottomSounding_ft <- 3.28 * dfProfileJoined$BottomSounding_m
dfProfileJoined$IntakeDepth_ft <- 3.28 * dfProfileJoined$IntakeDepth_m
#Interpolate reservoir storage from lake elevation
###dfProfileJoined$ActiveVolume_acft <- interp2(xi = dfProfileJoined$LakeElevation_ft,x=dfMeadElevStor$`Elevation (ft)` , y=dfMeadElevStor$`Live Storage (ac-ft)`, method="linear")
View(dfProfileJoined)
sStations <- c("LPCRRFG2", "LRCR0004")
dfProfileJoinedStats <- dfProfileJoined %>% filter(StationID %in% cStations)
dfProfileJoinedStats <- dfProfileJoined %>% filter(StationID %in% sStations)
View(dfProfileJoinedStats)
sStations <- c("LPCRRFG2", "LPCR0004")
dfProfileJoinedStats <- dfProfileJoined %>% filter(StationID %in% sStations)
View(dfProfileJoinedStats)
View(dfProfileJoinedStats)
dfProfileJoined$Year <- year(dfProfileJoined$CollectionDateTime.x)
dfProfileJoinedStats <- dfProfileJoined %>% filter(StationID %in% sStations)
View(dfProfileJoinedStats)
dfProfileJoined$PosDate <- as.POSIXct(dfProfileJoined$CollectionDateTime.x, format = "%Y/%m/%d %H:%M")
dfProfileJoined$PosDate <- as.POSIXct(dfProfileJoined$CollectionDateTime.x, format = "%m/%d/%Y %H:%M")
dfProfileJoined$Year <- year(dfProfileJoined$PosDate)
dfProfileJoinedStats <- dfProfileJoined %>% filter(StationID %in% sStations)
dfProfileJoined$IntakeElevation_ft <- dfProfileJoined$LakeElevation_ft - dfProfileJoined$IntakeDepth_ft
rm(list=ls())
cPackages <- c("versions", "googlesheets4", "dygraphs", "tidyquant", "xts", "tidyverse", "tidyquant","lubridate", "stringr", "rvest", "RColorBrewer", "readxl" )
# Install packages not yet installed
installed_packages <- cPackages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(cPackages[!installed_packages])
}
# Packages loading
invisible(lapply(cPackages, library, character.only = TRUE))
#Load the required library
#Load correct versions of libraries
install.versions('cli', '3.4.0')
# New function interp2 to return NAs for values outside interpolation range (from https://stackoverflow.com/questions/47295879/using-interp1-in-r)
interp2 <- function(x, y, xi = x, ...) {
yi <- rep(NA, length(xi));
sel <- which(xi >= range(x)[1] & xi <= range(x)[2]);
yi[sel] <- interp1(x = x, y = y, xi = xi[sel], ...);
return(yi);
}
### Stations we are interested in:
sStations <- c("LPCRRFG2", "LPCR0004")
#######
###Read all data data into R
sStationDataFile <- 'data/StationData_LakePowell_1964-2022.csv'
sSiteVisitDataFile <- 'data/SiteVisitData_LakePowell_1964-2022.csv'
sProfileDataFile <- 'data/ProfileData_LakePOwell_1965-2022.csv'
dfStationData <- read.csv(sStationDataFile)
dfSiteVisitData <- read.csv(sSiteVisitDataFile)
dfProfileData <- read.csv(sProfileDataFile)
# Read elevation-storage data in from Excel
sExcelFile <- 'data/Lake_Powell_Area_Capacity_Table_report_Final.xlsx'
dfPowellBathymetry <- read_excel(sExcelFile, sheet = "2017Bathymetry",  range = "A1:D582")
####### Join the data
# Join Profile data to site visit data
# Seems like this statement should work (joining on the datetime), but we lose the intake and elevation data
#dfProfileJoined <- left_join(dfProfileData, dfSiteVisitData, by = c("TripID" = "TripID", "StationID" = "StationID", "CollectionDateTime" = "CollectionDateTime"))
dfProfileJoined <- left_join(dfProfileData, dfSiteVisitData, by = c("TripID" = "TripID", "StationID" = "StationID"))
# Join Profile and StationData
dfProfileJoined <- left_join(dfProfileJoined, dfStationData, by = c("StationID" = "StationID"))
# Convert meters to feet
dfProfileJoined$Depth_ft <- 3.28 * dfProfileJoined$Depth_m
dfProfileJoined$LakeElevation_ft <- 3.28 * dfProfileJoined$LakeElevation_m
dfProfileJoined$BottomSounding_ft <- 3.28 * dfProfileJoined$BottomSounding_m
dfProfileJoined$IntakeDepth_ft <- 3.28 * dfProfileJoined$IntakeDepth_m
# Convert Date to POSIXct format R understands
dfProfileJoined$PosDate <- as.POSIXct(dfProfileJoined$CollectionDateTime.x, format = "%m/%d/%Y %H:%M")
# Calculate the year
dfProfileJoined$Year <- year(dfProfileJoined$PosDate)
# Calculate the intake elevation in feet to check that elevations are all the same
dfProfileJoined$IntakeElevationMid_ft <- dfProfileJoined$LakeElevation_ft - dfProfileJoined$IntakeDepth_ft
dfProfileJoined$MinimumPowerPool_ft <- 3490
#Filter on the stations we are interested in
dfProfileJoinedStats <- dfProfileJoined %>% filter(StationID %in% sStations)
print(unique(dfProfileJoined$Description))
print(unique(dfProfileJoined$StationID))
cUniqueStats <- unique(dfProfileJoined$StationID)
dfProfileJoinedStats <- dfProfileJoined %>% filter(StationID %in% sStations)
sStations <- c("LPCRRFG2", "LPCR0004")
dfProfileJoinedStats <- dfProfileJoined %>% filter(StationID %in% sStations)
dfProfileJoined <- left_join(dfProfileData, dfSiteVisitData, by = c("TripID" = "TripID", "StationID" = "StationID"))
# Join Profile and StationData
dfProfileJoined <- left_join(dfProfileJoined, dfStationData, by = c("StationID" = "StationID"))
# Convert meters to feet
dfProfileJoined$Depth_ft <- 3.28 * dfProfileJoined$Depth_m
dfProfileJoined$LakeElevation_ft <- 3.28 * dfProfileJoined$LakeElevation_m
dfProfileJoined$BottomSounding_ft <- 3.28 * dfProfileJoined$BottomSounding_m
dfProfileJoined$IntakeDepth_ft <- 3.28 * dfProfileJoined$IntakeDepth_m
# Convert Date to POSIXct format R understands
dfProfileJoined$PosDate <- as.POSIXct(dfProfileJoined$CollectionDateTime.x, format = "%m/%d/%Y %H:%M")
# Calculate the year
dfProfileJoined$Year <- year(dfProfileJoined$PosDate)
# Calculate the intake elevation in feet to check that elevations are all the same
dfProfileJoined$IntakeElevationMid_ft <- dfProfileJoined$LakeElevation_ft - dfProfileJoined$IntakeDepth_ft
dfProfileJoined$MinimumPowerPool_ft <- 3490
# Find the unique stations
cUniqueStats <- unique(dfProfileJoined$StationID)
#Filter on the stations we are interested in
dfProfileJoinedStats <- dfProfileJoined %>% filter(StationID %in% sStations)
sStations <- c("LPCRRFG2", "LPCR0004", "LPCR-0001")
dfProfileJoinedStats <- dfProfileJoined %>% filter(StationID %in% sStations)
dfProfileSummary <- dfProfileJoined %>% group_by(StationID, escription, Year )
dfProfileSummary <- dfProfileJoined %>% group_by(StationID, description, Year )
dfProfileSummary <- dfProfileJoined %>% group_by(StationID, Description, Year )
View(dfProfileSummary)
dfProfileSummary <- dfProfileJoined %>% group_by(StationID, Description, Year ) %>% summarize(Year= Year)
dfProfileSummary <- dfProfileJoined %>% group_by(StationID, Description) %>% summarize(MinYear = min(Year), MaxYear = max(Year))
dfProfileSummary <- dfProfileJoined %>% group_by(StationID, Description) %>% summarize(MinYear = min(Year), MaxYear = max(Year), Latitude = Latitude, Longitude = Longitude)
dfProfileSummary <- dfProfileJoined %>% group_by(StationID, Description) %>% summarize(MinYear = min(Year), MaxYear = max(Year), Latitude = mean(Latitude), Longitude = mean(Longitude))
sStations <- c("LPCRRFG2", "LPCR0004", "LPCR0006", "LPCR0024", "LPCR-0001")
dfProfileJoinedStats <- dfProfileJoined %>% filter(StationID %in% sStations)
sStations <- c("LPCRRFG2", "LPCR0004", "LPCR0006", "LPCR0024", "LPCR-0001")
dfProfileJoinedStats <- dfProfileJoined %>% filter(StationID %in% sStations)
dfProfileSummary <- dfProfileJoinedStats %>% group_by(StationID, Description) %>% summarize(MinYear = min(Year), MaxYear = max(Year), Latitude = mean(Latitude), Longitude = mean(Longitude))
cPackages <- c("versions", "googlesheets4", "dygraphs", "tidyquant", "xts", "tidyverse", "tidyquant","lubridate", "stringr", "rvest", "RColorBrewer", "readxl", "ggmap" )
# Install packages not yet installed
installed_packages <- cPackages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(cPackages[!installed_packages])
}
# Packages loading
invisible(lapply(cPackages, library, character.only = TRUE))
#Load the required library
#Load correct versions of libraries
install.versions('cli', '3.4.0')
lake_powell_bbox <- c(left = -114, bottom = 36, right = -110, top = 37.5)
map_base <- get_map(location = lake_powell_bbox, zoom = 9, maptype = "satellite") # or "terrain", "roadmap"
ggmap(map_base) +
geom_point(data = dfProfileSummary, aes(x = Longitude, y = Latitude, color = name), size = 3) +
coord_map() + # Or coord_quickmap() for a quicker approximation
labs(title = "Points on Lake Powell", x = "Longitude", y = "Latitude")
map_base <- get_map(location = lake_powell_bbox, zoom = 9, maptype = "satellite") # or "terrain", "roadmap"
lake_powell_bbox <- c(left = -114, bottom = 36, right = -110, top = 37.5)
map_base <- get_map(location = lake_powell_bbox, zoom = 9, maptype = "satellite", source = "osm") # or "terrain", "roadmap"
