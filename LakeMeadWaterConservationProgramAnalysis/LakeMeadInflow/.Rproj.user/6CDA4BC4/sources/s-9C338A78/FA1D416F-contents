---
title: "Lake Mead Inflow"
author: "David E. Rosenberg"
date: "July 26, 2024"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Description

This is an R Markdown document. This document shows/estimates Lake Mead inflow using 4 different methods. Each method gives different values. The 4 methods are:

1. Add U.S. Geological Service data from stream gages 
    A. Colorado River nr Peach Springs [9404200; https://waterdata.usgs.gov/monitoring-location/09404200/#parameterCode=00065&timeSeriesId=6324&period=P7D] (1990 to present)
    B. Virgin River at Littlefield [9415000; https://waterdata.usgs.gov/monitoring-location/09415000/#parameterCode=00065&period=P7D] (1930 to present)
    C. Las Vegas Wash Below LAKE LAS VEGAS NR BOULDER CITY, NV [09419800; https://waterdata.usgs.gov/monitoring-location/09419800/] (2002 to present)
    D. Mead Inflow = A + B + C    

2. Inflow data provided from the USBR Application Programming Interface (USBR API). Note this inflow data only goes from January 2015 to present. This data is retrieved from              https://www.usbr.gov/lc/region/g4000/riverops/_HdbWebQuery.html. In order to use this, you will need to know the region and Site Datatype ID (SDID). The lake Mead data will be with the Lower Colorado Regional Offices HDB. For the different values you mentioned, the SDID's you will need are as follows: Evaporation (SDID=1776), Inflow (SDID=2091), Storage (SDID=1721), and Release (SDID=1874). From there you can select the timestep you want, Instantaneous, Hourly, Daily, Monthly, as well as for what time span you want. A query looks like: https://www.usbr.gov/pn-bin/hdb/hdb.pl?svr=lchdb&sdi=1776%2C2091%2C1721%2C1874&tstp=MN&t1=2022-01-01T00:00&t2=2024-05-01T00:00&table=R&mrid=0&format=html.
This query dynamically builds the end date as most recent month with full data.`

3. Back calculate from Lake Mead storage, release, Nevada Diversion, and Lake Mead evaporation data retrieved from the same API as Method #2 (1990 to present).
       Lake Mead Inflow = [Change in Storage] + [Release] +[Nevada Diversion] + [Evaporation]

4. Back calculate from Lake Mead storage, release, Nevada Diversion, and Lake Mead evaporation (1990 to present). Here we use evaporation data from elevation-storag-area relationship from Colorado River Simulation System (CRSS) model

## Figures

1. Lake Mead Inflow, Evaporation, Available Water, and water conservation credits
2. Inflow timeseries by the first four inflow methods.
3. Inflow box-and-whiskers for the first four inflow methods.
4. Inflow histograms for the first four inflow methods.
5. Correlation between USGS Gaged flow, Reclamation Inflow, and Inflow estimated by back calculation of inflow. Includes linear regressions.
6. Difference in Lake Mead Inflow USGS Gages and Reclamation API
7. Correlation between evaporation reported by USBR API and Evaporation estimated by table
8. Time series of USGS gaged inflow
9. ICS account balances
10. ICS deposits.

## Data Sources

1. U.S.G.S. Application Program Interface (https://waterdata.usgs.gov/monitoring-location/)
2. Lake Mead Inflow, Evaporation, and Storage read in from USBR Application Programming Interface (API).  https://www.usbr.gov/lc/region/g4000/riverops/_HdbWebQuery.html
                 API query - https://www.usbr.gov/pn-bin/hdb/hdb.pl?svr=lchdb&sdi=1776%2C2091%2C1721%2C1874&tstp=MN&t1=2022-01-01T00:00&t2=2024-05-01T00:00&table=R&mrid=0&format=html
3. Lake Mead conservation account balances: USBR (2024). "Boulder Canyon Operations Office - Program and Activities: Water Accounting Reports".  https://www.usbr.gov/lc/region/g4000/wtracct.html. These annual reports are aggregated in the Excel file IntentionallyCreatedSurplus-Summary.xlsx.


## Requested Citation
David E. Rosenberg (2020). "Lake Mead Inflow". Utah State University. Logan, Utah. https://github.com/dzeke/ColoradoRiverCollaborate/tree/main/LakeMeadWaterConservationProgramAnalysis/LakeMeadInflow.


```{r LakeMeadInflow1, echo=FALSE, warning=FALSE, message=FALSE}

rm(list = ls())  #Clear history

#Load packages in one go
  #List of packages
  load.lib <- c("tidyverse", "readxl", "RColorBrewer", "dplyr", "expss", "reshape2", "pracma", "lubridate", "directlabels", "plyr", "stringr", "ggplot2", "ggpubr", "rvest", "tidyr", "dataRetrieval")
# Then we select only the packages that aren't currently installed.
  install.lib <- load.lib[!load.lib %in% installed.packages()]
# And finally we install the missing packages, including their dependency.
  for(lib in install.lib) install.packages(lib,dependencies=TRUE)
  # After the installation process completes, we load all packages.
  sapply(load.lib,require,character=TRUE)

# New function interpNA to return NAs for values outside interpolation range (from https://stackoverflow.com/questions/47295879/using-interp1-in-r)
  interpNA <- function(x, y, xi = x, ...) {
    yi <- rep(NA, length(xi));
    sel <- which(xi >= range(x)[1] & xi <= range(x)[2]);
    yi[sel] <- interp1(x = x, y = y, xi = xi[sel], ...);
    return(yi);
  }  
  
#Labels for each method to use in grouping and plotting
cMethods <- c("USGS Gages", "USBR API Inflow", "USBR API Back Calc", "USBR Back Calc\nwith Evap from Table", "CRSS", "Wang-Schmidt")
cColors <- c("Blue", "Red", "Pink", "Purple", "Brown", "Black")

##############################
### Inflow Calc Method #1. Add U.S. Geological Service data from stream gages
# Read in the USGS gaged data

##### Need to change to calendar year
##### Read in data from API

# Retrieve data
# Dynamically read to the current date
CurrDate <- as.Date(Sys.Date())
cYear <- year(CurrDate)
cMonth <- month(CurrDate)

# Calculate the prior month
if (cMonth == 1) {
  # We want December of the prior year
  sDate <- sprintf("%d-%d-01", cYear-1, 12)
} else {
  # We take the prior month of the same year
  sDate <- sprintf("%d-%d-01", cYear, cMonth - 1)
}


siteNumbers <- c("09404200", "09415000", "09419800")
parameterCd <- "00060" # Discharge in cfs
start.date <- "1990-01-01"
end.date <- sDate

for(site in siteNumbers){
  site_info <- readNWISsite(site) 
  dataTemp <- readNWISdata(siteNumbers = site, parameterCd = parameterCd, startDate = start.date, endDate = end.date)
  dataTemp$StationName <- site_info$station_nm

    if(site == siteNumbers[1]) {
    dataUSGS <- dataTemp
    }
  else {
    dataUSGS <- rbind(dataUSGS, dataTemp)
    }
  }

# Save the API data to csv to improve reproducibility and in case no internet
write.csv(dataUSGS, "USGSFlowData-MeadInflow.csv")

#Rename the data column to a useful name
cColHeaders <- colnames(dataUSGS)
cColHeaders[4] <- "Flow.cfs"
colnames(dataUSGS) <- cColHeaders
dataUSGS$date <- as.Date(dataUSGS$dateTime)
dataUSGS$Flow.acft <- 1.983 * dataUSGS$Flow.cfs
# Cast so each stream gage is a column
dfInflowsWide <- dcast(dataUSGS, date ~ StationName, value.var = "Flow.acft")
# Replace NAs with 0s
dfInflowsWide <- dfInflowsWide %>% replace(is.na(.), 0)

dfInflowsWide$MeadInflow <- dfInflowsWide$`COLORADO RVR ABV DIAMOND CREEK NR PEACH SPRINGS AZ` + dfInflowsWide$`LV WASH BLW LAKE LAS VEGAS NR BOULDER CITY, NV` + dfInflowsWide$`VIRGIN RV AT LITTLEFIELD, AZ`
dfInflowsWide$Year <- year(dfInflowsWide$date)

dfGCFFlowsUSGS <- dfInflowsWide %>% dplyr::group_by(Year) %>% dplyr::summarise(MeadInflow = sum(MeadInflow)/1e6)

dfGCFFlowsUSGS$Method <- cMethods[1]



```

# Figure 1. Lake Mead Storage, Water Conservation Account Balances, and anticipated Lake volume absent the water conservation program
```{r MeadStorageFig1, echo=FALSE, warning=FALSE, message=FALSE}

ggplot() +
  #Lake Mead Storage and Water Conservation Account balances as stacked area plot
  #As area
  geom_area(data=dfMeadStorageStackMelt, aes(x=DateAsValue, y=value, fill=variable, group=variable)) +
  #Reservoir level as line
    geom_line(data=dfMeadStorageStack %>% filter(Year <= nMaxYearICSData),aes(x=DateAsValue,y=MeadLevelWithoutICS, color="Combined"), size=1, color = pReds[6], linetype = "twodash") +
  
    geom_line(data=dfMeadStorageStack %>% filter(Year < nMaxYearResData + 1),aes(x=DateAsValue,y=MeadStorage, color="Combined"), size=1, color = "Black") +
  #Reservoir level without ICS program

  #lines for max capacity and protect elevation
  geom_hline(data=dfKeyMeadVolumes, aes(yintercept = Volume), linetype="longdash", size=1) +
  #lines for Interim Guidelines and Expiry
  geom_vline(data=dfKeyDates, aes(xintercept = Date), linetype = "dashed", size=1, color = pReds[9]) +
  
  #Labels for the areas
#  geom_text(data=dfKeyMeadTraceLabels %>% filter(Label != dfKeyMeadTraceLabels$Label[3]), aes(x=as.Date(sprintf("%.0f-01-01",xPosition)), y=Volume, label=as.character(Label)), size = 6, fontface="bold") +
#  geom_text(data=dfKeyMeadTraceLabels %>% filter(Label == dfKeyMeadTraceLabels$Label[3]), aes(x=as.Date(sprintf("%.0f-01-01",xPosition)), y=Volume, label=as.character(Label)), size = 5, fontface="bold", color = pBlues[3]) +
  geom_text(data=dfKeyMeadTraceLabels, aes(x=as.Date(sprintf("%.0f-01-01",xPosition)), y=Volume, label=as.character(Label)), size = 3, fontface="bold") +
  
  #Scales
  scale_x_date(limits= c(as.Date("2000-01-01"), as.Date("2026-01-01")), date_breaks = "4 year", date_labels = "%Y", sec.axis = sec_axis(~. +0, name = "", breaks = dfKeyDates$Date, labels = as.character(dfKeyDates$Label))) +
  #Secondary axis as Mead level
  scale_y_continuous(limits = c(0, NA),  sec.axis = sec_axis(~. +0, name = "Elevation (feet)", breaks = dfMeadPoolsPlot2$stor_maf, labels = dfMeadPoolsPlot2$label)) +
  
  
  scale_fill_manual(values=c(pBlues[3], pBlues[3], pBlues[5], pBlues[7])) +
  
  #    scale_y_continuous(breaks = c(0,5.98,9.6,12.2,dfMaxStor[2,2]),labels=c(0,5.98,9.6,12.2,dfMaxStor[2,2]),  sec.axis = sec_axis(~. +0, name = "Mead Level (feet)", breaks = c(0,5.98,9.6,12.2,dfMaxStor[2,2]), labels = c(895,1025,1075,1105,1218.8))) +
  #scale_x_discrete(breaks=cMonths, labels= cMonthsLabels) +
  #scale_x_continuous(breaks=seq(1960,2020,by=10), labels= seq(1960,2020,by=10)) +
  
  
  #scale_fill_manual(breaks=c(1:6),values = palBlues[2:7]) + #,labels = variable) + 
  theme_bw() +
  #coord_fixed() +
  labs(x="", y="Active Storage\n(MAF)", color = "") +
  theme(text = element_text(size=10), legend.title=element_blank(), legend.position ="none")