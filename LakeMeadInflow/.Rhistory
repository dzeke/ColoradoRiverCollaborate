#theme(text = element_text(size=20), legend.title=element_blank(), legend.text=element_text(size=18),
#      legend.position = c(0.8,0.7))
theme_bw() +
theme(text = element_text(size=20))
ggplot() +
#Ribbon from Inflow to available water
geom_ribbon(data = dfInflowICS, aes(x = WaterYear, max = MeadInflow - lBaselinePlot, min = AvailableWater - lBaselinePlot, fill="Evaporation")) +
#Inflow as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = MeadInflow - lBaselinePlot, color = "Inflow"), size = 1) + #color=Method shape=Method, size=6) +
#Available water as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = AvailableWater - lBaselinePlot, color = "Available Water"), size = 1) + #color=Method shape=Method, size=6) +
# ICS counts as stacked bar
geom_bar(data=dfICSCountMelt, aes(fill=variable,y=-value,x=WaterYear),position="stack", stat="identity") +
scale_fill_manual(name="Guide1",values = c(palGreys[3], palReds[7], palReds[9]),breaks=cNamesInflowICS[c(3, (nNumCols-1):nNumCols)], labels = c("Evaporation", sCreditTotals)) +
###scale_color_manual(name="Guide2", values=c("Black")) +
scale_color_manual(name="Guide2", values = c(palBlues[7], palBlues[9])) +
#Add line for 9.0 maf
geom_hline(yintercept = lHistorialAllocation - lBaselinePlot, color="black", linetype = "longdash", size = 1.5) +
# Set x-axis limits
xlim(min(dfUSBR_API_Agg$WaterYear),max(dfUSBR_API_Agg$WaterYear)) +
# Set the y-axis limits and breaks
scale_y_continuous(breaks=seq(-4,6,1), labels=seq(-4,6,1) + lBaselinePlot) +
#Make one combined legend
guides(color = guide_legend(""), fill = guide_legend("")) +
#facet_wrap( ~ Source) +
labs(x="", y="Volume\n(million acre-feet per year)") +
#theme(text = element_text(size=20), legend.title=element_blank(), legend.text=element_text(size=18),
#      legend.position = c(0.8,0.7))
theme_bw() +
theme(text = element_text(size=20))
lBaselinePlot <- 6   # Baseline value on plot from where bars for ICS deposits will show
ggplot() +
#Ribbon from Inflow to available water
geom_ribbon(data = dfInflowICS, aes(x = WaterYear, max = MeadInflow - lBaselinePlot, min = AvailableWater - lBaselinePlot, fill="Evaporation")) +
#Inflow as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = MeadInflow - lBaselinePlot, color = "Inflow"), size = 1) + #color=Method shape=Method, size=6) +
#Available water as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = AvailableWater - lBaselinePlot, color = "Available Water"), size = 1) + #color=Method shape=Method, size=6) +
# ICS counts as stacked bar
geom_bar(data=dfICSCountMelt, aes(fill=variable,y=-value,x=WaterYear),position="stack", stat="identity") +
scale_fill_manual(name="Guide1",values = c(palGreys[3], palReds[7], palReds[9]),breaks=cNamesInflowICS[c(3, (nNumCols-1):nNumCols)], labels = c("Evaporation", sCreditTotals)) +
###scale_color_manual(name="Guide2", values=c("Black")) +
scale_color_manual(name="Guide2", values = c(palBlues[7], palBlues[9])) +
#Add line for 9.0 maf
geom_hline(yintercept = lHistorialAllocation - lBaselinePlot, color="black", linetype = "longdash", size = 1.5) +
# Set x-axis limits
xlim(min(dfUSBR_API_Agg$WaterYear),max(dfUSBR_API_Agg$WaterYear)) +
# Set the y-axis limits and breaks
scale_y_continuous(breaks=seq(-5,6,1), labels=seq(-5,6,1) + lBaselinePlot) +
#Make one combined legend
guides(color = guide_legend(""), fill = guide_legend("")) +
#facet_wrap( ~ Source) +
labs(x="", y="Volume\n(million acre-feet per year)") +
#theme(text = element_text(size=20), legend.title=element_blank(), legend.text=element_text(size=18),
#      legend.position = c(0.8,0.7))
theme_bw() +
theme(text = element_text(size=20))
ggplot() +
#Ribbon from Inflow to available water
geom_ribbon(data = dfInflowICS, aes(x = WaterYear, max = MeadInflow - lBaselinePlot, min = AvailableWater - lBaselinePlot, fill="Evaporation")) +
#Inflow as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = MeadInflow - lBaselinePlot, color = "Inflow"), size = 1) + #color=Method shape=Method, size=6) +
#Available water as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = AvailableWater - lBaselinePlot, color = "Available Water"), size = 1) + #color=Method shape=Method, size=6) +
# ICS counts as stacked bar
geom_bar(data=dfICSCountMelt, aes(fill=variable,y=-value,x=WaterYear),position="stack", stat="identity") +
scale_fill_manual(name="Guide1",values = c(palGreys[3], palReds[7], palReds[9]),breaks=cNamesInflowICS[c(3, (nNumCols-1):nNumCols)], labels = c("Evaporation", sCreditTotals)) +
###scale_color_manual(name="Guide2", values=c("Black")) +
scale_color_manual(name="Guide2", values = c(palBlues[7], palBlues[9])) +
#Add line for 9.0 maf
geom_hline(yintercept = lHistorialAllocation - lBaselinePlot, color="black", linetype = "longdash", size = 1.5) +
# Set x-axis limits
xlim(min(dfUSBR_API_Agg$WaterYear),max(dfUSBR_API_Agg$WaterYear)) +
# Set the y-axis limits and breaks
scale_y_continuous(breaks=seq(-5,6,1), labels=c(1,0,seq(-5,6,1) + lBaselinePlot)) +
#Make one combined legend
guides(color = guide_legend(""), fill = guide_legend("")) +
#facet_wrap( ~ Source) +
labs(x="", y="Volume\n(million acre-feet per year)") +
#theme(text = element_text(size=20), legend.title=element_blank(), legend.text=element_text(size=18),
#      legend.position = c(0.8,0.7))
theme_bw() +
theme(text = element_text(size=20))
ggplot() +
#Ribbon from Inflow to available water
geom_ribbon(data = dfInflowICS, aes(x = WaterYear, max = MeadInflow - lBaselinePlot, min = AvailableWater - lBaselinePlot, fill="Evaporation")) +
#Inflow as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = MeadInflow - lBaselinePlot, color = "Inflow"), size = 1) + #color=Method shape=Method, size=6) +
#Available water as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = AvailableWater - lBaselinePlot, color = "Available Water"), size = 1) + #color=Method shape=Method, size=6) +
# ICS counts as stacked bar
geom_bar(data=dfICSCountMelt, aes(fill=variable,y=-value,x=WaterYear),position="stack", stat="identity") +
scale_fill_manual(name="Guide1",values = c(palGreys[3], palReds[7], palReds[9]),breaks=cNamesInflowICS[c(3, (nNumCols-1):nNumCols)], labels = c("Evaporation", sCreditTotals)) +
###scale_color_manual(name="Guide2", values=c("Black")) +
scale_color_manual(name="Guide2", values = c(palBlues[7], palBlues[9])) +
#Add line for 9.0 maf
geom_hline(yintercept = lHistorialAllocation - lBaselinePlot, color="black", linetype = "longdash", size = 1.5) +
# Set x-axis limits
xlim(min(dfUSBR_API_Agg$WaterYear),max(dfUSBR_API_Agg$WaterYear)) +
# Set the y-axis limits and breaks
scale_y_continuous(breaks=seq(-6,6,1), labels=c(1,0,seq(-5,6,1) + lBaselinePlot)) +
#Make one combined legend
guides(color = guide_legend(""), fill = guide_legend("")) +
#facet_wrap( ~ Source) +
labs(x="", y="Volume\n(million acre-feet per year)") +
#theme(text = element_text(size=20), legend.title=element_blank(), legend.text=element_text(size=18),
#      legend.position = c(0.8,0.7))
theme_bw() +
theme(text = element_text(size=20))
ggplot() +
#Ribbon from Inflow to available water
geom_ribbon(data = dfInflowICS, aes(x = WaterYear, max = MeadInflow - lBaselinePlot, min = AvailableWater - lBaselinePlot, fill="Evaporation")) +
#Inflow as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = MeadInflow - lBaselinePlot, color = "Inflow"), size = 1) + #color=Method shape=Method, size=6) +
#Available water as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = AvailableWater - lBaselinePlot, color = "Available Water"), size = 1) + #color=Method shape=Method, size=6) +
# ICS counts as stacked bar
geom_bar(data=dfICSCountMelt, aes(fill=variable,y=-value,x=WaterYear),position="stack", stat="identity") +
scale_fill_manual(name="Guide1",values = c(palGreys[3], palReds[7], palReds[9]),breaks=cNamesInflowICS[c(3, (nNumCols-1):nNumCols)], labels = c("Evaporation", sCreditTotals)) +
###scale_color_manual(name="Guide2", values=c("Black")) +
scale_color_manual(name="Guide2", values = c(palBlues[7], palBlues[9])) +
#Add line for 9.0 maf
geom_hline(yintercept = lHistorialAllocation - lBaselinePlot, color="black", linetype = "longdash", size = 1.5) +
# Set x-axis limits
xlim(min(dfUSBR_API_Agg$WaterYear),max(dfUSBR_API_Agg$WaterYear)) +
# Set the y-axis limits and breaks
scale_y_continuous(breaks=seq(-6,6,1), labels=c(1,0,seq(-4,6,1) + lBaselinePlot)) +
#Make one combined legend
guides(color = guide_legend(""), fill = guide_legend("")) +
#facet_wrap( ~ Source) +
labs(x="", y="Volume\n(million acre-feet per year)") +
#theme(text = element_text(size=20), legend.title=element_blank(), legend.text=element_text(size=18),
#      legend.position = c(0.8,0.7))
theme_bw() +
theme(text = element_text(size=20))
ggplot() +
#Ribbon from Inflow to available water
geom_ribbon(data = dfInflowICS, aes(x = WaterYear, max = MeadInflow - lBaselinePlot, min = AvailableWater - lBaselinePlot, fill="Evaporation")) +
#Inflow as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = MeadInflow - lBaselinePlot, color = "Inflow"), size = 1) + #color=Method shape=Method, size=6) +
#Available water as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = AvailableWater - lBaselinePlot, color = "Available Water"), size = 1) + #color=Method shape=Method, size=6) +
# ICS counts as stacked bar
geom_bar(data=dfICSCountMelt, aes(fill=variable,y=-value,x=WaterYear),position="stack", stat="identity") +
scale_fill_manual(name="Guide1",values = c(palGreys[3], palReds[7], palReds[9]),breaks=cNamesInflowICS[c(3, (nNumCols-1):nNumCols)], labels = c("Evaporation", sCreditTotals)) +
###scale_color_manual(name="Guide2", values=c("Black")) +
scale_color_manual(name="Guide2", values = c(palBlues[7], palBlues[9])) +
#Add line for 9.0 maf
geom_hline(yintercept = lHistorialAllocation - lBaselinePlot, color="black", linetype = "longdash", size = 1.5) +
# Set x-axis limits
xlim(min(dfUSBR_API_Agg$WaterYear),max(dfUSBR_API_Agg$WaterYear)) +
# Set the y-axis limits and breaks
scale_y_continuous(breaks=seq(-1,7,1), labels=c(1,0,seq(1,5,1) + lBaselinePlot)) +
#Make one combined legend
guides(color = guide_legend(""), fill = guide_legend("")) +
#facet_wrap( ~ Source) +
labs(x="", y="Volume\n(million acre-feet per year)") +
#theme(text = element_text(size=20), legend.title=element_blank(), legend.text=element_text(size=18),
#      legend.position = c(0.8,0.7))
theme_bw() +
theme(text = element_text(size=20))
seq(-1,7,1)
c(1,0,seq(1,5,1) + lBaselinePlot)
ggplot() +
#Ribbon from Inflow to available water
geom_ribbon(data = dfInflowICS, aes(x = WaterYear, max = MeadInflow - lBaselinePlot, min = AvailableWater - lBaselinePlot, fill="Evaporation")) +
#Inflow as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = MeadInflow - lBaselinePlot, color = "Inflow"), size = 1) + #color=Method shape=Method, size=6) +
#Available water as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = AvailableWater - lBaselinePlot, color = "Available Water"), size = 1) + #color=Method shape=Method, size=6) +
# ICS counts as stacked bar
geom_bar(data=dfICSCountMelt, aes(fill=variable,y=-value,x=WaterYear),position="stack", stat="identity") +
scale_fill_manual(name="Guide1",values = c(palGreys[3], palReds[7], palReds[9]),breaks=cNamesInflowICS[c(3, (nNumCols-1):nNumCols)], labels = c("Evaporation", sCreditTotals)) +
###scale_color_manual(name="Guide2", values=c("Black")) +
scale_color_manual(name="Guide2", values = c(palBlues[7], palBlues[9])) +
#Add line for 9.0 maf
geom_hline(yintercept = lHistorialAllocation - lBaselinePlot, color="black", linetype = "longdash", size = 1.5) +
# Set x-axis limits
xlim(min(dfUSBR_API_Agg$WaterYear),max(dfUSBR_API_Agg$WaterYear)) +
# Set the y-axis limits and breaks
scale_y_continuous(breaks=seq(-1,7,1), labels=c(1,0,seq(1,7,1) + lBaselinePlot)) +
#Make one combined legend
guides(color = guide_legend(""), fill = guide_legend("")) +
#facet_wrap( ~ Source) +
labs(x="", y="Volume\n(million acre-feet per year)") +
#theme(text = element_text(size=20), legend.title=element_blank(), legend.text=element_text(size=18),
#      legend.position = c(0.8,0.7))
theme_bw() +
theme(text = element_text(size=20))
ggplot() +
#Ribbon from Inflow to available water
geom_ribbon(data = dfInflowICS, aes(x = WaterYear, max = MeadInflow - lBaselinePlot, min = AvailableWater - lBaselinePlot, fill="Evaporation")) +
#Inflow as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = MeadInflow - lBaselinePlot, color = "Inflow"), size = 1) + #color=Method shape=Method, size=6) +
#Available water as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = AvailableWater - lBaselinePlot, color = "Available Water"), size = 1) + #color=Method shape=Method, size=6) +
# ICS counts as stacked bar
geom_bar(data=dfICSCountMelt, aes(fill=variable,y=-value,x=WaterYear),position="stack", stat="identity") +
scale_fill_manual(name="Guide1",values = c(palGreys[3], palReds[7], palReds[9]),breaks=cNamesInflowICS[c(3, (nNumCols-1):nNumCols)], labels = c("Evaporation", sCreditTotals)) +
###scale_color_manual(name="Guide2", values=c("Black")) +
scale_color_manual(name="Guide2", values = c(palBlues[7], palBlues[9])) +
#Add line for 9.0 maf
geom_hline(yintercept = lHistorialAllocation - lBaselinePlot, color="black", linetype = "longdash", size = 1.5) +
# Set x-axis limits
xlim(min(dfUSBR_API_Agg$WaterYear),max(dfUSBR_API_Agg$WaterYear)) +
# Set the y-axis limits and breaks
scale_y_continuous(breaks=seq(-2,7,1), labels=c(1,0,seq(1,8,1) + lBaselinePlot)) +
#Make one combined legend
guides(color = guide_legend(""), fill = guide_legend("")) +
#facet_wrap( ~ Source) +
labs(x="", y="Volume\n(million acre-feet per year)") +
#theme(text = element_text(size=20), legend.title=element_blank(), legend.text=element_text(size=18),
#      legend.position = c(0.8,0.7))
theme_bw() +
theme(text = element_text(size=20))
ggplot() +
#Ribbon from Inflow to available water
geom_ribbon(data = dfInflowICS, aes(x = WaterYear, max = MeadInflow - lBaselinePlot, min = AvailableWater - lBaselinePlot, fill="Evaporation")) +
#Inflow as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = MeadInflow - lBaselinePlot, color = "Inflow"), size = 1) + #color=Method shape=Method, size=6) +
#Available water as line
geom_line(data = dfInflowICS, aes(x= WaterYear, y = AvailableWater - lBaselinePlot, color = "Available Water"), size = 1) + #color=Method shape=Method, size=6) +
# ICS counts as stacked bar
geom_bar(data=dfICSCountMelt, aes(fill=variable,y=-value,x=WaterYear),position="stack", stat="identity") +
scale_fill_manual(name="Guide1",values = c(palGreys[3], palReds[7], palReds[9]),breaks=cNamesInflowICS[c(3, (nNumCols-1):nNumCols)], labels = c("Evaporation", sCreditTotals)) +
###scale_color_manual(name="Guide2", values=c("Black")) +
scale_color_manual(name="Guide2", values = c(palBlues[7], palBlues[9])) +
#Add line for 9.0 maf
geom_hline(yintercept = lHistorialAllocation - lBaselinePlot, color="black", linetype = "longdash", size = 1.5) +
# Set x-axis limits
xlim(min(dfUSBR_API_Agg$WaterYear),max(dfUSBR_API_Agg$WaterYear)) +
# Set the y-axis limits and breaks
scale_y_continuous(breaks=seq(-1,7,1), labels=c(1,0,seq(1,7,1) + lBaselinePlot)) +
#Make one combined legend
guides(color = guide_legend(""), fill = guide_legend("")) +
#facet_wrap( ~ Source) +
labs(x="", y="Volume\n(million acre-feet per year)") +
#theme(text = element_text(size=20), legend.title=element_blank(), legend.text=element_text(size=18),
#      legend.position = c(0.8,0.7))
theme_bw() +
theme(text = element_text(size=20))
rm(list = ls())  #Clear history
#Load packages in one go
#List of packages
load.lib <- c("tidyverse", "readxl", "RColorBrewer", "dplyr", "expss", "reshape2", "pracma", "lubridate", "directlabels", "plyr", "stringr", "ggplot2", "ggpubr", "rvest", "tidyr")
# Then we select only the packages that aren't currently installed.
install.lib <- load.lib[!load.lib %in% installed.packages()]
# And finally we install the missing packages, including their dependency.
for(lib in install.lib) install.packages(lib,dependencies=TRUE)
# After the installation process completes, we load all packages.
sapply(load.lib,require,character=TRUE)
# New function interpNA to return NAs for values outside interpolation range (from https://stackoverflow.com/questions/47295879/using-interp1-in-r)
interpNA <- function(x, y, xi = x, ...) {
yi <- rep(NA, length(xi));
sel <- which(xi >= range(x)[1] & xi <= range(x)[2]);
yi[sel] <- interp1(x = x, y = y, xi = xi[sel], ...);
return(yi);
}
#Labels for each method to use in grouping and plotting
cMethods <- c("USGS Gages", "USBR Application Program Interface", "USBR with Evap from Table", "USBR API - Inflow", "CRSS", "Wang-Schmidt")
cColors <- c("Blue", "Red", "Pink", "Purple", "Bronw", "Black")
# the Combined data frame will have the variables WaterYear, MeadInflow, Method
### Read in the Natural Flow data and convert it to annual flows
# Note used in calc of Mead Inflow. But keep anyway for backward compatibility
sExcelFileGrandCanyonFlow <- 'HistoricalNaturalFlow.xlsx'
dfGCFlows <- read_excel(sExcelFileGrandCanyonFlow, sheet = 'Total Natural Flow',  range = "U1:Z1324")
dfGCDates <- read_excel(sExcelFileGrandCanyonFlow, sheet = 'Total Natural Flow',  range = "A1:A1324")
#Merge and combine into one Data frame
dfGCFlows$Date <- dfGCDates$`Natural Flow And Salt Calc model Object.Slot`
#Calculate Grand Canyon Tributary flows as sum of Paria, Little Colorado River, Virgin, and intervening flows
#Just tribs (without intervening)
#dfGCFlows$Total <- dfGCFlows$`CoRivPowellToVirgin:PariaGains.LocalInflow` + dfGCFlows$`CoRivPowellToVirgin:LittleCoR.LocalInflow` +
#                          dfGCFlows$VirginRiver.Inflow
#Tribs + Gains above Hoover
dfGCFlows$Total <- dfGCFlows$`CoRivPowellToVirgin:PariaGains.LocalInflow` + dfGCFlows$`CoRivPowellToVirgin:LittleCoR.LocalInflow` +
dfGCFlows$VirginRiver.Inflow + dfGCFlows$`CoRivVirginToMead:GainsAboveHoover.LocalInflow` - dfGCFlows$`CoRivPowellToVirgin:GainsAboveGC.LocalInflow`
dfGCFlows$Year <- year(dfGCFlows$Date)
dfGCFlows$Month <- month(as.Date(dfGCFlows$Date,"%Y-%m-%d"))
dfGCFlows$WaterYear <- ifelse(dfGCFlows$Month >= 10,dfGCFlows$Year,dfGCFlows$Year + 1)
View(dfGCFlows)
#Convert to Water Year and sum by water year
dfGCFlowsByYear <- aggregate(dfGCFlows$Total, by=list(Category=dfGCFlows$WaterYear), FUN=sum)
dfLeeFerryByYear <- aggregate(dfGCFlows$`HistoricalNaturalFlow.AboveLeesFerry`, by=list(Category=dfGCFlows$WaterYear), FUN=sum)
#Change the Names
colnames(dfGCFlowsByYear) <- c("WaterYear","GCFlow")
colnames(dfLeeFerryByYear) <- c("WaterYear", "LeeFerryNaturalFlow")
dfGCFlowsByYear$LeeFerryNaturalFlow <- dfLeeFerryByYear$LeeFerryNaturalFlow
#Calculate Lake Mead Inflow as sum of GCFlow and Lee Ferry Natural Flow
dfGCFlowsByYear$MeadInflowNat <- dfGCFlowsByYear$GCFlow + dfGCFlowsByYear$LeeFerryNaturalFlow
sExcelFileUSGSFlow <- 'USGSInterveningFlowData.xlsx'
dfGCFlowsUSGS <- read_excel(sExcelFileUSGSFlow, sheet = 'Combined',  range = "A1:E34")
cColNames <- colnames(dfGCFlowsUSGS)
cColNames[1] <- "WaterYear"
cColNames[2] <- "LeeFerryFlow"
cColNames[5] <- "LasVegasWash"
colnames(dfGCFlowsUSGS) <- cColNames
dfGCFlowsUSGS <- dfGCFlowsUSGS %>% replace(is.na(.),0)
#Calculate the total
#Grand Canyon interveening flow
dfGCFlowsUSGS$GCFlow <- dfGCFlowsUSGS$`Colorado River near Peach Springs` - dfGCFlowsUSGS$LeeFerryFlow + dfGCFlowsUSGS$`Virgin River at Littlefield`
#Lake Mead inflow
dfGCFlowsUSGS$MeadInflow <- dfGCFlowsUSGS$`Colorado River near Peach Springs` + dfGCFlowsUSGS$`Virgin River at Littlefield` + dfGCFlowsUSGS$LasVegasWash
dfGCFlowsUSGS$Method <- cMethods[1]
#Dynamically read to the current date
CurrDate <- as.Date(Sys.Date())
cYear <- year(CurrDate)
cMonth <- month(CurrDate)
#Calculate the prior month
if (cMonth == 1) {
# We want December of the prior year
sDate <- sprintf("%d-%d-01", cYear-1, 12)
} else {
# We take the prior month of the same year
sDate <- sprintf("%d-%d-01", cYear, cMonth - 1)
}
#Construct the USBR API call by reading data up to the prior month
usbr_url <- paste0("https://www.usbr.gov/pn-bin/hdb/hdb.pl?svr=lchdb&sdi=1776%2C2091%2C1721%2C1874&tstp=MN&t1=1990-01-01T00:00&t2=", sDate, "T00:00&table=R&mrid=0&format=html")
usbr_MeadData <- read_html(usbr_url)
pkg_data <- usbr_MeadData |>
html_element("table") |>
html_table()
dfUSBR_API <- data.frame(pkg_data)
#Save the API data to csv to improve reproducibility and in case no internet
write.csv(dfUSBR_API, "dfUSBR_API.csv")
dfSDIDcode <- data.frame(code = c(1776, 2091, 1721, 1874),
Field = c("Evaporation", "Inflow", "Storage", "Release"),
Units = c("acre-feet", "??", "acre-feet", "cfs"))
cSDID <- colnames(dfUSBR_API)
cSDID[2:5] <-dfSDIDcode$Field
colnames(dfUSBR_API) <- cSDID
dfUSBR_API$Date <- as.Date(dfUSBR_API$DATETIME, "%m/%d/%Y %h:%m")
dfUSBR_API$Date <- mdy_hm(dfUSBR_API$DATETIME)
dfUSBR_API$Month <- month(dfUSBR_API$Date)
dfUSBR_API$Year <- year(dfUSBR_API$Date)
dfUSBR_API$Day <- day(dfUSBR_API$Date)
dfUSBR_API$Release <- dfUSBR_API$Release * 1.983 * days_in_month(dfUSBR_API$DATETIME) / 1e6
dfUSBR_API$Inflow <- dfUSBR_API$Inflow * 1.983 * days_in_month(dfUSBR_API$DATETIME) / 1e6
dfUSBR_API <- data.frame(pkg_data)
#Save the API data to csv to improve reproducibility and in case no internet
write.csv(dfUSBR_API, "dfUSBR_API.csv")
#Turn the SDID Code # into meaningful variable names
dfSDIDcode <- data.frame(code = c(1776, 2091, 1721, 1874),
Field = c("Evaporation", "Inflow", "Storage", "Release"),
Units = c("acre-feet", "??", "acre-feet", "cfs"))
cSDID <- colnames(dfUSBR_API)
cSDID[2:5] <-dfSDIDcode$Field
colnames(dfUSBR_API) <- cSDID
#Convert DATETIME to time series format R understands
dfUSBR_API$Date <- as.Date(dfUSBR_API$DATETIME, "%m/%d/%Y %h:%m")
dfUSBR_API$Date <- mdy_hm(dfUSBR_API$DATETIME)
#Add month, year, and day variables
dfUSBR_API$Month <- month(dfUSBR_API$Date)
dfUSBR_API$Year <- year(dfUSBR_API$Date)
dfUSBR_API$Day <- day(dfUSBR_API$Date)
#Conversions to million acre-feet
#Convert average cfs per month to million acre-feet per month
dfUSBR_API$Release <- dfUSBR_API$Release * 1.983 * days_in_month(dfUSBR_API$DATETIME) / 1e6
dfUSBR_API$Inflow <- dfUSBR_API$Inflow * 1.983 * days_in_month(dfUSBR_API$DATETIME) / 1e6
#Convert acre-feet to million acre-feet
dfUSBR_API$Evaporation <- dfUSBR_API$Evaporation / 1e6
dfUSBR_API$Storage <- dfUSBR_API$Storage / 1e6
#Calculate water year
dfUSBR_API$WaterYear <- ifelse(dfUSBR_API$Month >= 10, dfUSBR_API$Year + 1, dfUSBR_API$Year)
#Filter out rows with NaN - Evaporation at early months and years
dfUSBR_API2 <- na.omit(dfUSBR_API) # We will come back and fill in the evaporation using an evap rate and the storage-area curve
#Filter out years < 2004 because some months have NAs for Evap
dfUSBR_API2 <- dfUSBR_API2 %>% filter(WaterYear > 2004)
#Pick the first day of October as day to take storage for the year
dfUSBR_Stor <- dfUSBR_API2 %>% select(WaterYear, Month, Day, Storage ) %>% filter(Month == 10, Day == 1)
#Calculate the difference
dfUSBR_Stor$DeltaStorage <- c(diff(dfUSBR_Stor$Storage),0)
#Aggregate to Month and Year
dfUSBR_API_Agg <- dfUSBR_API2 %>% dplyr::group_by(WaterYear) %>% dplyr::summarise(Evaporation = sum(Evaporation), Release = sum(Release), Inflow = sum(Inflow))
dfUSBR_API_Agg <- left_join(dfUSBR_API_Agg, dfUSBR_Stor, by = c("WaterYear" = "WaterYear"))
View(dfUSBR_API_Agg)
View(dfGCFlowsUSGS)
View(dfUSBR_API_Agg)
dfUSBR_API <- data.frame(pkg_data)
#Save the API data to csv to improve reproducibility and in case no internet
write.csv(dfUSBR_API, "dfUSBR_API.csv")
#Turn the SDID Code # into meaningful variable names
dfSDIDcode <- data.frame(code = c(1776, 2091, 1721, 1874),
Field = c("Evaporation", "Inflow", "Storage", "Release"),
Units = c("acre-feet", "??", "acre-feet", "cfs"))
cSDID <- colnames(dfUSBR_API)
cSDID[2:5] <-dfSDIDcode$Field
colnames(dfUSBR_API) <- cSDID
#Convert DATETIME to time series format R understands
dfUSBR_API$Date <- as.Date(dfUSBR_API$DATETIME, "%m/%d/%Y %h:%m")
dfUSBR_API$Date <- mdy_hm(dfUSBR_API$DATETIME)
#Add month, year, and day variables
dfUSBR_API$Month <- month(dfUSBR_API$Date)
dfUSBR_API$Year <- year(dfUSBR_API$Date)
dfUSBR_API$Day <- day(dfUSBR_API$Date)
#Conversions to million acre-feet
#Convert average cfs per month to million acre-feet per month
dfUSBR_API$Release <- dfUSBR_API$Release * 1.983 * days_in_month(dfUSBR_API$DATETIME) / 1e6
dfUSBR_API$Inflow <- dfUSBR_API$Inflow * 1.983 * days_in_month(dfUSBR_API$DATETIME) / 1e6
dfUSBR_API$Evaporation <- dfUSBR_API$Evaporation / 1e6
dfUSBR_API$Storage <- dfUSBR_API$Storage / 1e6
#Calculate water year
dfUSBR_API$WaterYear <- ifelse(dfUSBR_API$Month >= 10, dfUSBR_API$Year + 1, dfUSBR_API$Year)
#Filter out rows with NaN - Evaporation at early months and years
dfUSBR_API2 <- na.omit(dfUSBR_API) # We will come back and fill in the evaporation using an evap rate and the storage-area curve
View(dfUSBR_API2)
dfUSBR_API <- data.frame(pkg_data)
#Save the API data to csv to improve reproducibility and in case no internet
write.csv(dfUSBR_API, "dfUSBR_API.csv")
#Turn the SDID Code # into meaningful variable names
dfSDIDcode <- data.frame(code = c(1776, 2091, 1721, 1874),
Field = c("Evaporation", "Inflow", "Storage", "Release"),
Units = c("acre-feet", "??", "acre-feet", "cfs"))
cSDID <- colnames(dfUSBR_API)
cSDID[2:5] <-dfSDIDcode$Field
colnames(dfUSBR_API) <- cSDID
#Convert DATETIME to time series format R understands
dfUSBR_API$Date <- as.Date(dfUSBR_API$DATETIME, "%m/%d/%Y %h:%m")
dfUSBR_API$Date <- mdy_hm(dfUSBR_API$DATETIME)
#Add month, year, and day variables
dfUSBR_API$Month <- month(dfUSBR_API$Date)
dfUSBR_API$Year <- year(dfUSBR_API$Date)
dfUSBR_API$Day <- day(dfUSBR_API$Date)
dfUSBR_API$Release <- dfUSBR_API$Release * 1.983 * days_in_month(dfUSBR_API$DATETIME) / 1e6
dfUSBR_API$Release <- dfUSBR_API$Release * 1.983 * days_in_month(dfUSBR_API$DATETIME) / 1e6
dfUSBR_API <- data.frame(pkg_data)
#Save the API data to csv to improve reproducibility and in case no internet
write.csv(dfUSBR_API, "dfUSBR_API.csv")
#Turn the SDID Code # into meaningful variable names
dfSDIDcode <- data.frame(code = c(1776, 2091, 1721, 1874),
Field = c("Evaporation", "Inflow", "Storage", "Release"),
Units = c("acre-feet", "??", "acre-feet", "cfs"))
cSDID <- colnames(dfUSBR_API)
cSDID[2:5] <-dfSDIDcode$Field
colnames(dfUSBR_API) <- cSDID
#Convert DATETIME to time series format R understands
dfUSBR_API$Date <- as.Date(dfUSBR_API$DATETIME, "%m/%d/%Y %h:%m")
dfUSBR_API$Date <- mdy_hm(dfUSBR_API$DATETIME)
#Add month, year, and day variables
dfUSBR_API$Month <- month(dfUSBR_API$Date)
dfUSBR_API$Year <- year(dfUSBR_API$Date)
dfUSBR_API$Day <- day(dfUSBR_API$Date)
dfUSBR_API$Inflow <- dfUSBR_API$Inflow * 1.983 * days_in_month(dfUSBR_API$DATETIME) / 1e6
days_in_month(dfUSBR_API$DATETIME)
dfUSBR_API$DaysInMonth <- days_in_month(dfUSBR_API$DATETIME)
dfUSBR_API$DaysInMonth <- days_in_month(dfUSBR_API$Date)
dfUSBR_API$Inflow <- dfUSBR_API$Inflow * 1.983 * dfUSBR_API$DaysInMonth / 1e6
dfUSBR_API$Release <- dfUSBR_API$Release * 1.983 * dfUSBR_API$DaysInMonth / 1e6
dfUSBR_API$Evaporation <- dfUSBR_API$Evaporation / 1e6
dfUSBR_API$Storage <- dfUSBR_API$Storage / 1e6
dfUSBR_API <- data.frame(pkg_data)
write.csv(dfUSBR_API, "dfUSBR_API.csv")
#Turn the SDID Code # into meaningful variable names
dfSDIDcode <- data.frame(code = c(1776, 2091, 1721, 1874),
Field = c("Evaporation", "Inflow", "Storage", "Release"),
Units = c("acre-feet", "??", "acre-feet", "cfs"))
cSDID <- colnames(dfUSBR_API)
cSDID[2:5] <-dfSDIDcode$Field
colnames(dfUSBR_API) <- cSDID
#Convert DATETIME to time series format R understands
dfUSBR_API$Date <- as.Date(dfUSBR_API$DATETIME, "%m/%d/%Y %h:%m")
dfUSBR_API$Date <- mdy_hm(dfUSBR_API$DATETIME)
#Add month, year, and day variables
dfUSBR_API$Month <- month(dfUSBR_API$Date)
dfUSBR_API$Year <- year(dfUSBR_API$Date)
dfUSBR_API$Day <- day(dfUSBR_API$Date)
dfUSBR_API$DaysInMonth <- days_in_month(dfUSBR_API$Date)
dfUSBR_API$Inflow <- dfUSBR_API$Inflow * 1.983 * dfUSBR_API$DaysInMonth / 1e6
dfUSBR_API <- data.frame(pkg_data)
#Save the API data to csv to improve reproducibility and in case no internet
write.csv(dfUSBR_API, "dfUSBR_API.csv")
#Turn the SDID Code # into meaningful variable names
dfSDIDcode <- data.frame(code = c(1776, 2091, 1721, 1874),
Field = c("Evaporation", "Inflow", "Storage", "Release"),
Units = c("acre-feet", "??", "acre-feet", "cfs"))
cSDID <- colnames(dfUSBR_API)
cSDID[2:5] <-dfSDIDcode$Field
colnames(dfUSBR_API) <- cSDID
#Convert DATETIME to time series format R understands
dfUSBR_API$Date <- as.Date(dfUSBR_API$DATETIME, "%m/%d/%Y %h:%m")
dfUSBR_API$Date <- mdy_hm(dfUSBR_API$DATETIME)
#Add month, year, and day variables
dfUSBR_API$Month <- month(dfUSBR_API$Date)
dfUSBR_API$Year <- year(dfUSBR_API$Date)
dfUSBR_API$Day <- day(dfUSBR_API$Date)
dfUSBR_API$DaysInMonth <- days_in_month(dfUSBR_API$Date)
dfUSBR_API$Inflow <- dfUSBR_API$Inflow / 1e6
dfUSBR_API$Release <- dfUSBR_API$Release * 1.983 * dfUSBR_API$DaysInMonth / 1e6
dfUSBR_API$Evaporation <- dfUSBR_API$Evaporation / 1e6
dfUSBR_API$Storage <- dfUSBR_API$Storage / 1e6
dfUSBR_API$WaterYear <- ifelse(dfUSBR_API$Month >= 10, dfUSBR_API$Year + 1, dfUSBR_API$Year)
#Filter out rows with NaN - Evaporation at early months and years
dfUSBR_API2 <- na.omit(dfUSBR_API) # We will come back and fill in the evaporation using an evap rate and the storage-area curve
#Filter out years < 2004 because some months have NAs for Evap
dfUSBR_API2 <- dfUSBR_API2 %>% filter(WaterYear > 2004)
#Pick the first day of October as day to take storage for the year
dfUSBR_Stor <- dfUSBR_API2 %>% select(WaterYear, Month, Day, Storage ) %>% filter(Month == 10, Day == 1)
dfUSBR_Stor$DeltaStorage <- c(diff(dfUSBR_Stor$Storage),0)
#Aggregate to Month and Year
dfUSBR_API_Agg <- dfUSBR_API2 %>% dplyr::group_by(WaterYear) %>% dplyr::summarise(Evaporation = sum(Evaporation), Release = sum(Release), Inflow = sum(Inflow))
#Aggregate to Month and Year
#dfUSBR_API_Agg <- dfUSBR_API2 %>% dplyr::group_by(WaterYear, Month) %>% dplyr::summarise(Evaporation = sum(Evaporation), Release = sum(Release))
#Join the annual delta storage to the annual release and evaporation data
dfUSBR_API_Agg <- left_join(dfUSBR_API_Agg, dfUSBR_Stor, by = c("WaterYear" = "WaterYear"))
dfUSBR_API_Agg$MeadInflow <- dfUSBR_API_Agg$DeltaStorage +  dfUSBR_API_Agg$Release +  dfUSBR_API_Agg$Evaporation
dfUSBR_API_Agg$Method <- cMethods[2]
#Use Evaporation table look up from storage
#Create a new data frame
dfUSBR_FromEvapTable <- dfUSBR_API_Agg
dfUSBR_FromEvapTable$MeadInflow <- dfUSBR_FromEvapTable$DeltaStorage +  dfUSBR_FromEvapTable$Release +  dfUSBR_FromEvapTable$EvaporationFromTable
dfUSBR_FromEvapTable$Method <- cMethods[3]
View(dfUSBR_API)
View(dfUSBR_API)
